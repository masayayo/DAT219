using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TournamentPage.Models;
using TournamentPage.Data;
using Microsoft.AspNetCore.Mvc.Rendering;
using Hangfire;
using System.Data.SqlClient;
using Microsoft.AspNetCore.Owin;
using Microsoft.AspNetCore.Mvc.Formatters.Json;
using Newtonsoft.Json;

namespace TournamentPage.Services
{
    public class BackgroundService
    {
        private ApplicationDbContext db;
        public BackgroundService(ApplicationDbContext db)
        {
             this.db = db;
        }


        /* Below is the functions used to generate the first round of a tournament.
        A Hangfire background worker is assigned to execute CheckTournamentRegisterDate() each minute for 
        tournaments where the RegisterDateEnd is due.
        The rest of the bracket data is generated by the jQuery Brackets library when scores are updated. */

        // Function for the background worker that checks all the end register dates for tournaments, and launches the GenerateRoundSingle
        // when it has ended.
        public void CheckTournamentRegisterDate(){

            var result = db.Tournament
            .Where(t => t.RegisterDateEnd <= DateTime.Now && t.BracketsJSON == null)
            .Select(i => i.TournamentId).ToListAsync().Result;

            Console.WriteLine("Check has been successful. Found " + result.Count() + " tournaments where the registerdate had ended.");

            if(result.Count() > 0){
                Console.WriteLine("Generating first round brackets...");
                for(int i = 0; i < result.Count(); i++){
                    GenerateRoundSingle(result.ElementAt(i), 0);
                }
                
            }
        }


        // Generate number of brackets
        public int GenerateNumBrackets(int numTeams){
            var numBrackets = numTeams / 2;
            return numBrackets;
        }

        // Standardized Round Generation function for Single Elemenation

        public void GenerateRoundSingle(int TournamentId, int roundNum){

            // Get all the teams who's in the 
             var teams = db.TournamentTeam
                .Where(t => t.Tournament.TournamentId == TournamentId)
                .Select(t => t.Team).ToListAsync().Result;

                

            // Team List
            var teamList = teams;

            // Check if the roundnumber is 0. If it is, randomize the list for a randomized tournament.
            if(roundNum == 0){
                var rnd = new Random();
                teamList.OrderBy(item => rnd.Next());
            } 

            // Brackets will always be half of the teamamount.
            var numRounds = roundNum;
            var numBrackets = (teamList.Count() / (numRounds + 1)) / 2;

            // Create a list for bracket storage
            List<Brackets> brackets = new List<Brackets>();

            // Populate the array with data and print it out. 
            int teamCounter = 0;
            
            for (int x = 0; x < numBrackets; x++) {
                for (int y = 0; y < 2; y++) {
                    Brackets bracket = new Brackets();
                    bracket.Round = 0;
                    bracket.Bracket = x;
                    bracket.TeamName = teamList.ElementAt(teamCounter).TeamName;
                    bracket.Score = null;
                    brackets.Add(bracket);
                    teamCounter++;
                }
            }

            var json = RoundSingleToJSON(brackets);

            // Save the bracket-data to the tournament
            Tournament bT = db.Tournament.FirstOrDefault(t => t.TournamentId == TournamentId);
            bT.BracketsJSON = json;
            db.SaveChanges();
        }

        // This function converts the array from GenerateRoundSingle to json for use in the JQuery Brackets
        public string RoundSingleToJSON(List<Brackets> brackets){

            var JSONbrackets = JsonConvert.SerializeObject(brackets);

            return JSONbrackets;
        }
    }
}